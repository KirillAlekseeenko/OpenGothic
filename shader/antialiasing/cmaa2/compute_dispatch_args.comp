#version 460

#extension GL_ARB_separate_shader_objects       : enable
#extension GL_GOOGLE_include_directive          : enable
#extension GL_EXT_control_flow_attributes       : enable

#include "cmaa2_common.glsl"

struct VkDispatchIndirectCommand {
  uint  x;
  uint  y;
  uint  z;
  };

struct VkDrawIndirectCommand {
  uint  vertexCount;
  uint  instanceCount;
  uint  firstVertex;
  uint  firstInstance;
  };

layout(binding = 8, std430) buffer UboWorkingExecuteIndirectBuffer {
  VkDispatchIndirectCommand candidateCmd;
  VkDrawIndirectCommand     applyCmd;
  //uvec4 g_workingExecuteIndirectBuffer;
  };

layout(push_constant, std140) uniform PushConstant {
  uint setupProcessCandidatesPassFlag;
  } push;

layout(local_size_x = 1) in;

void main() {
  if(push.setupProcessCandidatesPassFlag != 0) {
    uint shapeCandidateCount = controlBuffer.shapeCandidateCount;

    uint appendBufferMaxCount = workingShapeCandidates.length();
    shapeCandidateCount = min(shapeCandidateCount, appendBufferMaxCount);

    candidateCmd.x = (shapeCandidateCount + CMAA2_PROCESS_CANDIDATES_NUM_THREADS - 1) / CMAA2_PROCESS_CANDIDATES_NUM_THREADS;
    candidateCmd.y = 1;
    candidateCmd.z = 1;

    controlBuffer.subsequentPassWorkloadSize = shapeCandidateCount;
    } else /*setup deferred apply process*/ {
    uint blendLocationCount = controlBuffer.blendLocationCount;

    uint appendBufferMaxCount = workingDeferredBlendLocationList.length();
    blendLocationCount = min(blendLocationCount, appendBufferMaxCount);

    applyCmd.vertexCount   = blendLocationCount * 4; // 4 points per quad
    applyCmd.instanceCount = 1;
    applyCmd.firstVertex   = 0;
    applyCmd.firstInstance = 0;

    controlBuffer.subsequentPassWorkloadSize = blendLocationCount;
    controlBuffer.blendLocationCount         = 0;
    controlBuffer.shapeCandidateCount        = 0;
    controlBuffer.blendColorSamplesCount     = 0;
    }
  }
