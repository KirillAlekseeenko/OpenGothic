#version 460

#extension GL_ARB_separate_shader_objects       : enable
#extension GL_GOOGLE_include_directive          : enable
#extension GL_EXT_control_flow_attributes       : enable

#include "common.glsl"
#include "cmaa2_common.glsl"

layout(rgba8, binding = 8) uniform writeonly image2D outputColor;

layout(local_size_x = 4, local_size_y = CMAA2_DEFERRED_APPLY_NUM_THREADS) in;

void finalUAVStore(uvec2 pixelPos, vec3 color) {
#if CMAA2_UAV_STORE_CONVERT_TO_SRGB
  color = srgbEncode(color);
#endif

  imageStore(outputColor, ivec2(pixelPos), vec4(color, 1));
  }

void main() {
  const uint numCandidates = workingControlBuffer.subsequentPassWorkloadSize;

  const uint currentCandidate = gl_GlobalInvocationID.y;
  const uint currentQuadOffsetXY = gl_LocalInvocationID.x;

  if(currentCandidate >= numCandidates)
    return;

  uint pixelID = workingDeferredBlendLocationList[currentCandidate];
  uvec2 quadPos = uvec2((pixelID >> 16), pixelID & 0xFFFF);
  const ivec2 qeOffsets[4] = ivec2[4](ivec2(0, 0), ivec2(1, 0), ivec2(0, 1), ivec2(1, 1));
  uvec2 pixelPos = quadPos * 2u + uvec2(qeOffsets[currentQuadOffsetXY]);

  uint counterIndexWithHeader = imageLoad(workingDeferredBlendItemListHeads, ivec2(quadPos)).r;

  vec4 outColors = vec4(0);

  const uint maxLoops = 32u;
  for(uint i = 0; (counterIndexWithHeader != 0xFFFFFFFF) && (i < maxLoops); i++) {
    uint offsetXY = (counterIndexWithHeader >> 30) & 0x03;
    bool isComplexShape = bool((counterIndexWithHeader >> 26) & 0x01);

    uvec2 val = workingDeferredBlendItemList[counterIndexWithHeader & ((1u << 26) - 1)];

    counterIndexWithHeader = val.x;

    if(offsetXY == currentQuadOffsetXY) {
      vec3 color = internalUnpackColor(val.y);
      float weight = 0.8 + 1.0 * float(isComplexShape);
      outColors += vec4(color * weight, weight);
      }
    }

  if(outColors.a == 0) 
    return;

  vec4 outColor = vec4(outColors);
  outColor.rgb /= outColor.a;
  finalUAVStore(pixelPos, outColor.rgb);
  }
