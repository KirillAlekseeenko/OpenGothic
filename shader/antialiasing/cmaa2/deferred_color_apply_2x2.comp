#version 460

#extension GL_ARB_separate_shader_objects       : enable
#extension GL_GOOGLE_include_directive          : enable
#extension GL_EXT_control_flow_attributes       : enable

#include "common.glsl"
#include "cmaa2_common.glsl"

#if defined(GL_VERTEX_SHADER)
out gl_PerVertex {
  vec4 gl_Position;
  float gl_PointSize;
  };

layout(location = 0) out flat uint  currentQuadOffsetXY;
layout(location = 1) out flat uint  counterIndexWithHeader;

void main() {
  const uint  currentCandidate = gl_VertexIndex/4;
  currentQuadOffsetXY          = gl_VertexIndex%4;

  const ivec2 viewportSize = textureSize(sceneTonemapped, 0);
  const uint  pixelID      = workingDeferredBlendLocationList[currentCandidate];
  const ivec2 quadPos      = ivec2((pixelID >> 16), pixelID & 0xFFFF);
  const ivec2 qeOffsets[4] = ivec2[4](ivec2(0, 0), ivec2(1, 0), ivec2(0, 1), ivec2(1, 1));
  const uvec2 pixelPos     = quadPos * 2 + qeOffsets[currentQuadOffsetXY];

  counterIndexWithHeader = imageLoad(workingDeferredBlendItemListHeads, quadPos).r;
  gl_Position            = vec4((vec2(pixelPos+0.5)/vec2(viewportSize))*2.0-1.0, 0, 1);
  gl_PointSize           = 1;
  }
#elif defined(GL_FRAGMENT_SHADER)
layout(location = 0) out vec4 result;
layout(location = 0) in flat uint  currentQuadOffsetXY;
layout(location = 1) in flat uint  inCounterIndexWithHeader;

void main() {
  uint counterIndexWithHeader = inCounterIndexWithHeader;

  vec4 outColors = vec4(0);
  const uint maxLoops = 32u;
  for(uint i = 0; (counterIndexWithHeader != 0xFFFFFFFF) && (i < maxLoops); i++) {
    uint  offsetXY       = (counterIndexWithHeader >> 30) & 0x03;
    bool  isComplexShape = bool((counterIndexWithHeader >> 26) & 0x01);
    uvec2 val            = workingDeferredBlendItemList[counterIndexWithHeader & ((1u << 26) - 1)];

    counterIndexWithHeader = val.x;

    if(offsetXY == currentQuadOffsetXY) {
      vec3  color  = internalUnpackColor(val.y);
      float weight = 0.8 + 1.0 * float(isComplexShape);
      outColors += vec4(color * weight, weight);
      }
    }

  if(outColors.a == 0)
    discard;

  result = vec4(outColors.rgb/outColors.a, 1);
  }
#elif defined(GL_COMPUTE_SHADER)
layout(rgba8, binding = 8) uniform writeonly image2D outputColor;

void finalUAVStore(uvec2 pixelPos, vec3 color) {
#if CMAA2_UAV_STORE_CONVERT_TO_SRGB
  color = srgbEncode(color);
#endif

  imageStore(outputColor, ivec2(pixelPos), vec4(color, 1));
  }

layout(local_size_x = 4, local_size_y = CMAA2_DEFERRED_APPLY_NUM_THREADS) in;
void main() {
  const uint numCandidates       = controlBuffer.subsequentPassWorkloadSize;

  const uint currentCandidate    = gl_GlobalInvocationID.y;
  const uint currentQuadOffsetXY = gl_LocalInvocationID.x;

  if(currentCandidate >= numCandidates)
    return;

  uint pixelID = workingDeferredBlendLocationList[currentCandidate];
  uvec2 quadPos = uvec2((pixelID >> 16), pixelID & 0xFFFF);
  const ivec2 qeOffsets[4] = ivec2[4](ivec2(0, 0), ivec2(1, 0), ivec2(0, 1), ivec2(1, 1));
  uvec2 pixelPos = quadPos * 2u + uvec2(qeOffsets[currentQuadOffsetXY]);

  uint counterIndexWithHeader = imageLoad(workingDeferredBlendItemListHeads, ivec2(quadPos)).r;

  vec4 outColors = vec4(0);

  const uint maxLoops = 32u;
  for(uint i = 0; (counterIndexWithHeader != 0xFFFFFFFF) && (i < maxLoops); i++) {
    uint offsetXY = (counterIndexWithHeader >> 30) & 0x03;
    bool isComplexShape = bool((counterIndexWithHeader >> 26) & 0x01);

    uvec2 val = workingDeferredBlendItemList[counterIndexWithHeader & ((1u << 26) - 1)];

    counterIndexWithHeader = val.x;

    if(offsetXY == currentQuadOffsetXY) {
      vec3 color = internalUnpackColor(val.y);
      float weight = 0.8 + 1.0 * float(isComplexShape);
      outColors += vec4(color * weight, weight);
      }
    }

  if(outColors.a == 0) 
    return;

  vec4 outColor = vec4(outColors);
  outColor.rgb /= outColor.a;
  finalUAVStore(pixelPos, outColor.rgb);
  }
#endif
